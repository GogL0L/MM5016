#+title: Project 1
#+description: 
#+PROPERTY: header-args :tangle ./project1.py :padline 2
* Head
#+begin_src python :results output :session
from math import sqrt, cos, pi
#+end_src

#+RESULTS:

* Code for submethods

** Statitstics

*** Average
#+begin_src python :results output :session
def average(data_set):
    """ Given a list of data [a1, a2, a3, ..., an], this returns
    the average given by (a1 + a2 + a3 + ... + an) / n.
    """
    n = len(data_set)
    return sum(data_set) / n
#+end_src

#+RESULTS:



*** Standard deviation
#+begin_src python :results output :session
def standard_deviation(estimated_data, correct_data):
    """ Given estimated_data = [e1, e2, e3, ..., en] and
    correct_data = [c1, c2, c3, ..., cn], this returns the
    squareroot of the variance, i.e. 
    (((e1 - c1)^2 + (e2 - c2)^2 + ... + (en - cn)^2) / n)^0.5.
    """
    n = len(estimated_data)
    differences = [estimated_data[i] - correct_data[i] for i in range(n)]
    differences_squared = list(map(lambda x: x ** 2, differences))
    return sqrt(average(differences_squared))
#+end_src

#+RESULTS:

**** test
#+begin_src python :results output :session :tangle no
edata = [4, -4, 2, 2]
cdata = [0, 0, 0, 1]
print(standard_deviation(edata, cdata))
#+end_src

#+RESULTS:
: 3.0413812651491097



*** Biggest error
#+begin_src python :results output :session
def biggest_error(estimated_data, correct_data):
    """ Returns the biggest error difference between an estimated
    data point and its correct value.
    """
    n = len(estimated_data)
    differences = [estimated_data[i] - correct_data[i] for i in range(n)]
    differences_abs = [abs(differences[i]) for i in range(n)]
    biggest_error_index = differences_abs.index(max(differences_abs))
    biggest_error = differences[biggest_error_index]
    return biggest_error
    
#+end_src

#+RESULTS:

**** test
#+begin_src python :results output :session :tangle no
edata = [-4, 4, 2, 2]
cdata = [0, 0, 0, -5]
big = biggest_error(edata, cdata)
print(big)
#+end_src

#+RESULTS:
: 7



** ODE solvers

*** Runge-Kutta

#+begin_src python :results output :session
def runge_kutta_method(derivative, initial_value, stepsize):
    """ Given that 'derivative' is a function of (x,y)
    and that the 'initial_value' is a tuple of the form
    (x0, y(x0)), this method returns a function that
    approximates y using runge kutta method in the equation 
    dy/dx = derivative(x,y).
    """


    def y(x):
        x0, y0 = initial_value
        xk, yk = x0, y0
        while x0 <= xk < x:
            k1 = derivative(xk,yk)
            k2 = derivative(xk + stepsize / 2, yk + stepsize * k1 / 2)
            k3 = derivative(xk + stepsize / 2, yk + stepsize * k2 / 2)
            k4 = derivative(xk + stepsize, yk + stepsize * k3)
            x_next = xk + stepsize 
            y_next = yk + (1/6) * stepsize * (k1 + 2 * k2 + 2 * k3 + k4)
            xk, yk = x_next, y_next
        return yk

    
    return y
#+end_src

#+RESULTS:


**** test
#+begin_src python :results output :session :tangle no
f = runge_kutta_method(lambda x,y: y, (0,1), 0.01)
print(f(1))
print("yello")
#+end_src

#+RESULTS:
: 2.718281828234403
: yello




*** Heuns's method
#+begin_src python :results output :session
def heun_method(derivative, initial_value, stepsize):
    """ Given that 'derivative' is a function of (x,y)
    and that the 'initial_value' is a tuple of the form
    (x0, y(x0)), this method returns a function that
    approximates y using heun's method in the equation 
    dy/dx = derivative(x,y).
    """


    def y(x):
        x0, y0 = initial_value
        xk, yk = x0, y0
        while x0 <= xk < x:
            x_next = xk + stepsize 
            y_bar = yk + stepsize * derivative(xk,yk)
            y_next = yk + (stepsize / 2) * (derivative(xk, yk) +
                                            derivative(x_next, y_bar))
            xk, yk = x_next, y_next
        return yk

    
    return y
#+end_src

#+RESULTS:

**** test
#+begin_src python :results output :session :tangle no
f = heun_method(lambda x,y: y, (0,1), 0.1)
print(f(1))
print("yello")
#+end_src

#+RESULTS:
: 2.9990593355020874
: yello




*** Euler's method
#+begin_src python :results output :session
def euler_method(derivative, initial_value, stepsize):
    """ Given that 'derivative' is a function of (x,y)
    and that the 'initial_value' is a tuple of the form
    (x0, y(x0)), this method returns a function that
    approximates y in the equation dy/dx = derivative(x,y).
    """
    step_to_goal = lambda x, goal: x+stepsize if x < goal else x - stepsize
    y_next = lambda x, y, goal: (y + stepsize * derivative(x,y) if x < goal
                                 else y - stepsize * derivative(x,y) )


    def y(x):
        x0, y0 = initial_value
        xk, yk = x0, y0
        while x0 <= xk < x or x0 >= xk > x:
            xk = step_to_goal(xk, x)
            yk = y_next(xk, yk, x)
        return yk

    
    return y
#+end_src

#+RESULTS:

***** test
#+begin_src python :results output :session :tangle no
f = euler_method(lambda x,y: y, (0,1), 0.1)
print(f(1))
print("ello")
#+end_src

#+RESULTS:
: 2.33436821409
: ello




*** Problem 2 Adams-Bashforth

#+begin_src python :results output :session
## Problem 2: Adams-Bashforth
def bashforth_method(derivative, initial_value_orbit, stepsize):
    """ Given that 'derivative' is a function of (x,y) and that the 'initial_value' is a tuple of the form
    (x0, y(x0)), this method returns a function that
    approximates y using the Adams-Bashforth method in the equation 
    dy/dx = derivative(x,y).
    """


    def y(x):
        orbit = initial_value_orbit.copy()
        while 0 <= orbit[-1][0] < x:
            (x0,y0), (x1,y1) = orbit[-2:]
            x_next = x1 + stepsize 
            y_next = (y1 + (3/2) * stepsize * derivative(x1,y1)
                      - (1/2) * stepsize * derivative(x0,y0))
            orbit.append((x_next, y_next))
            
        return orbit[-1][1]

    
    return y

## To get the adams-Bashforth method:
problem_2_bashforth = bashforth_method(problem_2_derivative,
                                             problem_2_init_orbit,
                                             problem_2_stepsize)

#+end_src

#+RESULTS:

**** test
#+begin_src python :results output :session :tangle no
f = bashforth_method(problem_2_derivative ,problem_2_init_orbit, problem_2_stepsize)
g = problem_2_runge_kutta
print(f(4))
print(g(4))
print(len(problem_2_init_orbit))
#+end_src

#+RESULTS:



*** Problem 2 Adams-Moulton

#+begin_src python :results output :session
## Problem 2: Adams-Moulton
def moulton_method(derivative, initial_value_orbit, stepsize):
    """ Given that 'derivative' is a function of (x,y) and that the 'initial_value' is a tuple of the form
    (x0, y(x0)), this method returns a function that
    approximates y using the Adams-Moulton method in the equation 
    dy/dx = derivative(x,y).
    """


    def y(x):
        orbit = initial_value_orbit.copy()
        while 0 <= orbit[-1][0] < x:
            (x0,y0), (x1,y1) = orbit[-2:]
            euler = euler_method(derivative, (x1,y1), stepsize)
            x_next = x1 + stepsize 
            y_next_approx = euler(x_next)
            
            y_next = (y1 + stepsize * ( (5/12) * derivative(x_next, y_next_approx)
                                        + (2/3) * derivative(x1,y1)
                                        - (1/12) * derivative(x0, y0)))
            orbit.append((x_next, y_next))
            
        return orbit[-1][1]

    
    return y

## To get the Adams-Moulton method:
#f = trapezoidal_method( problem_2_derivative ,problem_2_init_orbit, problem_2_stepsize)
problem_2_moulton = moulton_method(problem_2_derivative,
                                   problem_2_init_orbit,
                                   problem_2_stepsize)
#+end_src

#+RESULTS:

**** test
#+begin_src python :results output :session :tangle no
f = moulton_method( problem_2_derivative, problem_2_init_orbit, problem_2_stepsize)
print(f(1))
#+end_src

#+RESULTS:


* Project 1 tasks

** Function
#+begin_src python :results output :session
def F(t,u):
    """ The function symbolising the second the derivative from
    the ODE for Project 1. I.e du/dt = cos(pi * t) + u(t).
    """
    return cos(pi * t) + u
#+end_src

#+RESULTS:

*** test
#+begin_src python :results output :session :tangle no
print(F(1,2))
#+end_src

#+RESULTS:
: 1.0



** task A (Euler's method)

** task B (Runge-Kutta second order)



** task C (Runge-Kutta fourth order)



** task D (Any multi-step method, in my case Adams-Bashforth)



