#+title: Lab 6 MM5016
#+description: QR method
#+PROPERTY: header-args :tangle ./lab6.py :padline 2

* Code

** Linear algebra stuff

*** Dot product
#+begin_src python :results output :session
def dot_product(v,u):
    """ Takes the dot product of the vectors v and u. I.e. the inner product
    given that the coordinates are in a orthonormal basis.
    """
    n = len(v)
    return sum([v[k]*u[k] for k in range(n)])
#+end_src

#+RESULTS:

*** vector add
#+begin_src python :results output :session
def vector_add(v,u):
    """ Add vectors componentwise. """
    n = len(v)
    return [v[k] + u[k] for k in range(n)]
#+end_src

#+RESULTS:

*** vector sub
#+begin_src python :results output :session
def vector_sub(v,u):
    """ Add vectors componentwise. """
    n = len(v)
    return [v[k] - u[k] for k in range(n)]
#+end_src

#+RESULTS:

*** vector sum
#+begin_src python :results output :session
def vector_sum(list_of_vectors, size=1):
    """ Returns the sum of the list. """
    n = size
    zero = [0 for i in range(n)]
    if list_of_vectors == []:
        return zero
    else:
        n = len(list_of_vectors[0])
        zero = [0 for i in range(n)]
        return vector_add(list_of_vectors[0],
                          vector_sum(list_of_vectors[1:], size=n))
#+end_src

#+RESULTS:

*** test vector sum
#+begin_src python :results output :session :tangle no
print(vector_sum([[1,2],[3,4],[1,1]]))
#+end_src

#+RESULTS:
: [5, 7]

*** Scalar product
#+begin_src python :results output :session
def scalar_product(m,v):
    """ Takes the scalar product of the scalar m and the vector v. """
    n = len(v)
    return [m * v[k] for k in range(n)]
#+end_src

#+RESULTS:

*** Projection
#+begin_src python :results output :session
def projection(u,v):
    """ Takes the projection of v on u, given that the coordinates
    are in a orthnormal basis.
    """
    scalar = dot_product(u,v) / dot_product(u,u)
    return scalar_product(scalar, u)
    
#+end_src

#+RESULTS:

*** Test of above
#+begin_src python :results output :session :tangle no
u,v = [3,3], [5,0]
print(projection(v,u))
#+end_src

#+RESULTS:
: [3.0, 0.0]

*** Transpose
#+begin_src python :results output :session
def transpose(matrix):
    """ Transposes a square matrix. """
    n = len(matrix)
    return [[matrix[i][j] for i in range(n)] for j in range(n)]
#+end_src

#+RESULTS:

** Gram-Schmidit
#+begin_src python :results output :session
def gram_schmidt(basis):
    """ Returns a orthonormal basis. """
    n = len(basis)
    a = basis
    u = lambda k: a[0] if k==0 else (
        vector_sub(a[k],
                   vector_sum([projection(u(j), a[k])
                          for j in range(0,k-1)])))
    e = [scalar_product(1 / dot_product(u(k), u(k)), u(k) ) for k in range(0,n)]
    return e

print(gram_schmidt([[2,0],[0,3]]))
#+end_src

#+RESULTS:

** gram test
#+begin_src python :results output :session :tangle no
print(gram_schmidt([[2,0],[0,3]]))
#+end_src

#+RESULTS:

** qr decompose
#+begin_src python :results output :session
def qr_decompose(A):
    """ Returns a unitary matrix Q and an upper triangular matrix R
    such that A = QR.
    """
    n = len(A)
    a = lambda i: tranpose(A)[i]
    R = [[dot_product(e(i),a(j)) for j in range(n)] for i in range(n)]
#+end_src

#+RESULTS:


* Test
