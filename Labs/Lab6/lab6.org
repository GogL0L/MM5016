#+title: Lab 6 MM5016
#+description: QR method
#+PROPERTY: header-args :tangle ./lab6.py :padline 2

* Code

** Linear algebra stuff

*** Transpose
#+begin_src python :results output :session
def transpose(matrix):
    """ Transposes a square matrix. """
    n = len(matrix)
    return [[matrix[i][j] for i in range(n)] for j in range(n)]
#+end_src

#+RESULTS:

*** Dot product
#+begin_src python :results output :session
def dot_product(v,u):
    """ Takes the dot product of the vectors v and u. I.e. the inner product
    given that the coordinates are in a orthonormal basis.
    """
    n = len(v)
    return sum([v[k]*u[k] for k in range(n)])
#+end_src

#+RESULTS:

*** vector add
#+begin_src python :results output :session
def vector_add(v,u):
    """ Add vectors componentwise. """
    n = len(v)
    return [v[k] + u[k] for k in range(n)]
#+end_src

#+RESULTS:

*** vector sub
#+begin_src python :results output :session
def vector_sub(v,u):
    """ Add vectors componentwise. """
    n = len(v)
    if n == 0:
        return []
    return [v[k] - u[k] for k in range(n)]
#+end_src

#+RESULTS:

*** vector sum
#+begin_src python :results output :session
def vector_sum(list_of_vectors, size=1):
    """ Returns the sum of the list. """
    n = size
    zero = [0 for i in range(n)]
    if list_of_vectors == []:
        return zero
    else:
        n = len(list_of_vectors[0])
        zero = [0 for i in range(n)]
        return vector_add(list_of_vectors[0],
                          vector_sum(list_of_vectors[1:], size=n))
#+end_src

#+RESULTS:

**** test vector sum
#+begin_src python :results output :session :tangle no
print(vector_sum([[2,2],[3,4],[1,1]]))
#+end_src

#+RESULTS:
: [6, 7]

*** Scalar product
#+begin_src python :results output :session
def scalar_product(m,v):
    """ Takes the scalar product of the scalar m and the vector v. """
    n = len(v)
    return [m * v[k] for k in range(n)]
#+end_src

#+RESULTS:

*** Projection
#+begin_src python :results output :session
def projection(u,v):
    """ Takes the projection of v on u, given that the coordinates
    are in a orthnormal basis.
    """
    scalar = dot_product(u,v) / dot_product(u,u)
    return scalar_product(scalar, u)
    
#+end_src

#+RESULTS:

*** Test of above
#+begin_src python :results output :session :tangle no
u,v = [3,3], [5,0]
print(projection(v,u))
#+end_src

#+RESULTS:
: [3.0, 0.0]

** Gram-Schmidit
#+begin_src python :results output :session
def gram_schmidt(basis):
    """ Returns a orthonormal basis. """
    n = len(basis)
    a = basis
    u = lambda k: a[0] if k==0 else (
        vector_sub(a[k],
                   vector_sum([projection(u(j), a[k])
                               for j in range(0,k-1)])))
    e = [scalar_product(1 / dot_product(u(k), u(k)), u(k) ) for k in range(0,n)]
    return e
#+end_src

#+RESULTS:


*** gram test
#+begin_src python :results output :session :tangle no
print(gram_schmidt([[2,0],[0,3]]))
#+end_src

#+RESULTS:

** qr decompose
#+begin_src python :results output :session
def qr_decompose(A):
    """ Returns a unitary matrix Q and an upper triangular matrix R
    such that A = QR.
    """
    n = len(A)
    a = lambda i: tranpose(A)[i]
    R = [[dot_product(e(i),a(j)) for j in range(n)] for i in range(n)]
#+end_src

#+RESULTS:


* Test
** Gram-Schmidit 2
#+begin_src python :results output :session
def gram_schmidt(basis):
    """ Returns an orthonormal basis. """
    n = len(basis)
    if n <= 1:
        return basis
    else:
        tail_orthogonal_basis = gram_schmidt(basis[:-1])
        head_original_basis = basis[-1]
        project_head_on = lambda u: projection(u, head_original_basis)
        non_orthogonal_components = list(map(project_head_on,
                                             tail_orthogonal_basis))
        non_orthogonal_component = vector_sum(non_orthogonal_components)
        head_orthogonal_basis = vector_sub(head_original_basis,
                                           non_orthogonal_component)
        return tail_orthogonal_basis + [head_orthogonal_basis]
#+end_src

#+RESULTS:


*** gram test
#+begin_src python :results output :session :tangle no
b = gram_schmidt([[2,1,3],[0,3,4],[0,0,5]])
b1, b2 = b[1], b[2]
print("product of", b1, "and", b2, ":")
print(dot_product(b1, b2))
#+end_src

#+RESULTS:
: product of [-2.142857142857143, 1.9285714285714286, 0.7857142857142856] and [-1.2000000000000002, -1.92, 1.44] :
: 0.0
** Test av list comprehension
#+begin_src python :results output :session :tangle no
stuff = [1,2,3,4,5]
print(stuff[:4])
#+end_src

#+RESULTS:
: [1, 2, 3, 4]
** map pÃ¥ empty list
#+begin_src python :results output :session :tangle no
print(list(map(lambda x: 2*x, [])))
#+end_src

#+RESULTS:
: []
** range 1
#+begin_src python :results output :session :tangle no
print(list(range(1)))
#+end_src

#+RESULTS:
: [0]

