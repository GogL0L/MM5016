#+TITLE: MM5016 Lab Assignment 6 (QR method)
#+DATE: \today
#+AUTHOR: John MÃ¶ller
#+OPTIONS: num:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:nil todo:t |:t
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: se
#+LaTeX_CLASS: notesse
#+LATEX_HEADER: \input{/home/john/texstuff/org/env.tex}
#+LATEX_HEADER: \input{/home/john/texstuff/org/bold.tex}
#+STARTUP: latexpreview

* Task 1
** exe: 1 :ignore:
#+LATEX: \begin{exercise}[1]  \label{exe:1}
Find a QR decomposition for the matrix based on the Gram-Schmidt method.
\begin{align*}
A=
\left( \begin{array}{c c c}
0  &  1  &  1 \\
1  &  1  &  2 \\
0  &  0  &  3
\end{array} \right)
.
\end{align*}

#+LATEX: \end{exercise}

** sol:  :ignore:
#+LATEX: \begin{solution}[1]  \label{sol:1}
To QR decompose \( A \) we will interpret the columns of \( A \)
as three column vectors \( A = ( a_1 , a_2, a_3) \) expressed in an orthonormal
basis \( \beta \). By the Gram-Schmidt method we will find an orthonormal
basis  
\( \gamma \) such that if \( r_1, r_2 , r_3 \) are the respective vectors \( a_1, a_2 , a_3 \)
in the basis \( \gamma \), then the matrix \( R = (r_1, r_2, r_3) \) we be an upper
triangular matrix.

By the Gram-Schmidt method we will have an orthogonal basis and add our
new vector by removing all components that are unorthogonal relative to
the given orthogonal basis. We will get these components by projecting
our new vector on the vectors in the orthogonal basis. Then we can add
an arbitrary ammount of new vectors by using this defintion recursively.
When we're done we will normalise all our vectors in the basis and thus
it will be our orthonormal basis \( \gamma \).

So let \( v_k \) denote the orthogonal basis vectors we are looking for
that we will in the end normalise to get the orthonormal basis.
So we will start by simply letting \( v_1 = a_1 \) as the set
\( \{ v_1 \}  \) is orthogonal by definition.

We will get \( v_2 \) by removing the \( v_1 \) parallel component of \( a_2 \):
\begin{align*}
v_2  &  = a_2 - \text{proj} _{v_1} (a_2) \\
& = a_2 - \frac{\left< v_1, a_2 \right> }{|v_1| ^2} v_1 \\
& = a_2 - v_1 \\
& = a_2 - a_1 \\
& = (1,1,0)^{t} - (0,1,0)^{t} \\
& = (1,0,0)^{t} 
.
\end{align*}

From this we can also conclude that \( a_2 = v_1 + v_2 \) which we will
use when determinening \( r_2 \).


We will do the same process with \( a_3 \) to obtain \( v_3 \), but this
time we need to remove both the \( v_1 \) and \( v_2 \) parallel components:
\begin{align*}
v_3  &  = a_3 - \text{proj} _{v_1}(a_3) - \text{proj} _{v_2}(a_3) \\
& = a_3 - \frac{\left< v_1, a_3 \right> }{| v_1 | ^2} v_1
- \frac{\left< v_2, a_3 \right> }{| v_2 | ^2} v_2 \\
& = a_3 - 2v_1 - v_2 \\
& = (1,2,3)^{t} - 2(0,1,0)^{t} - (1,0,0)^{t} \\
& = (0,0,3)^{t} 
.
\end{align*}
From this we can also conclude that \( a_3 = 2v_1 + v_2 + v_3 \), which we will
use when determining \( r_3 \).

So now we have an orthogonal basis
\begin{align*}
\{ v_1, v_2, v_3 \} = \{
\left( \begin{array}{c}
0 \\ 1 \\ 0
\end{array} \right)
\left( \begin{array}{c}
1 \\ 0 \\ 0
\end{array} \right)
\left( \begin{array}{c}
0 \\ 0 \\ 3
\end{array} \right)
 \} 
.
\end{align*}

As each vector is has a single coordinate we can easily see
that we can normalise it my dividing by 


#+LATEX: \end{solution}
