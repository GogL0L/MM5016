#+title: Lab 11: Boundary Value Problems
#+description: 
#+PROPERTY: header-args :tangle ./lab11.py :padline 2



* Header
#+begin_src python :results output :session :padline 0
import matplotlib.pyplot as plt
import numpy as np


## Description
"""
The methods are written to output the desired function. In order to
see the solutions to all the tasks run this as a python 3 file
in a terminal.
"""
#+end_src

#+RESULTS:

* Linear algebra från tidigare labbar

** matrix multiply
#+begin_src python :results output :session
def matrix_multiply(matrix1, matrix2):
    m = len(matrix1)
    n = len(matrix2)
    p = len(matrix2[0])
    element = lambda i,j: sum([matrix1[i][k] * matrix2[k][j]
                               for k in range(n)])
    row = lambda i: [element(i,j) for j in range(p)]
    return [row(i) for i in range(m)]
#+end_src

#+RESULTS:

** Transpose
#+begin_src python :results output :session
def transpose(matrix):
    """ Transposes an n by m matrix. """
    n = len(matrix)
    m = len(matrix[0])
    return [[matrix[i][j] for i in range(n)] for j in range(m)]
#+end_src

#+RESULTS:

*** Test av transpose
#+begin_src python :results output :session :tangle no
matrix = [[1,2,3],[4,5,6],[7,8,9]]
vector = [[1],[2],[3]]
print("Matrix tranposed:", transpose(matrix))
print("Vector tranposed:", transpose(vector))
#+end_src

#+RESULTS:
: Matrix tranposed: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
: Vector tranposed: [[1, 2, 3]]

** test av allt ovanför
#+begin_src python :results output :session :tangle no
print(matrix_multiply([[1,0],[0,1]], [[3],[4]]))
print(create_identity(3))
print(switch(0,1,3))
print(add_multiple_of_row_to_other_row(3,0,1,3))
print(matrix_multiply(scale_row(3,1,3), [[1,2,3],[4,5,6],[7,8,9]]))
#+end_src

#+RESULTS:
: [[3], [4]]

* Code

** Tridiagonal solver
#+begin_src python :results output :session
def tridiagonal_elimination(A,y):
    """ Returns the solution x to the equation Ax = y,
    where A is an n by n tridiagonal matrix and
    y is an n dimensional column vector. Algorithm copied
    from wikipedia.
    """
    n = len(y)
    a = lambda i: A[i][i-1]
    b = lambda i: A[i][i]
    c = lambda i: A[i][i+1]
    d = lambda i: y[i][0]


    def c_prim(i):
        if i == 0:
            return c(i) / b(i)
        else:
            return c(i) / (b(i) - a(i) * c_prim(i-1))


    def d_prim(i):
        if i == 0:
            return d(i) / b(i)
        else:
            return (d(i) - a(i) * d_prim(i-1)) / (b(i) - a(i) * c_prim(i-1))


    def x(i):
        if i == n-1:
            return d_prim(i)
        else:
            return d_prim(i) - c_prim(i) * x(i+1)


    x_vector = [[x(i)] for i in range(n)]
    return x_vector
#+end_src

#+RESULTS:

*** test
#+begin_src python :results output :session :tangle no
matrix = [[2,3,0,0], [5,7,11,0], [0, 13, 17, 23], [0,0,4,6]]
vector = [[1], [2], [3], [4]]
x = tridiagonal_elimination(matrix, vector)
print("x:", x)
print("vector:", vector)
print("matrix times x:", matrix_multiply(matrix, x))
#+end_src

#+RESULTS:
: x: [[1.9061413673232903], [-0.9374275782155268], [-0.08806488991888758], [0.7253765932792583]]
: vector: [[1], [2], [3], [4]]
: matrix times x: [[1.0], [2.0], [3.0000000000000036], [3.999999999999999]]



** Finite difference method
#+begin_src python :results output :session
def finite_difference_method(p, q, r, ya, yb, interval, partitions):
    """ Numerically solves the function y(x) from the equation 
    y''(x) = p(x) y' + q(x) y + r(x) with boundary values y(a) = ya
    and y(b) = yb, with the specified stepsize, in the interval given
    as a tuple (left, right) symbolising that x ranges from
    left <= x <= right. This function then returns a list of x values
    partitioned according to the interval and stepsize aswell as a corresponding 
    list of y values.
    """
    n = partitions
    left, right = interval
    h = (left - right) / n
    x = np.linspace(left, right, n+1)
    
    first_row_diagonal = [-2 - h ** 2 * q(x[1]), 1 - (h/2) * p(x[1])]
    last_row_diagonal = [1 + (h/2) * p(x[n-1]), -2 - h ** 2 * q(x[n-1])]
    row_i_diagonal = lambda i: [1 + (h/2) * p(x[i]),
                                -2 - h ** 2 * q(x[i]),
                                1 - (h/2) * p(x[i])]
    f = [[h ** 2 * r(x[1]) - (1 + (h/2) * p(x[1])) * ya if i == 1
          else h ** 2 * r(x[n-1]) - (1 - (h/2) * p(x[n-1])) * yb if i == n-1
          else h ** 2 * r(x[i])] for i in range(1,n)]

    A = [first_row_diagonal + (n-1-2) * [0] if i==1
         else (n-1-2) * [0] + last_row_diagonal if i == n-1
         else (i-1) * [0] + row_i_diagonal(i) + (n-1-i) * [0]
         for i in range(1,n)]
    #print("A:", A)
    #print("len of A:", len(A))
    #print("f:", f)
    u = tridiagonal_elimination(A,f)
    return x, transpose([[ya]] + u + [[yb]])[0]
#+end_src

#+RESULTS:

*** test
#+begin_src python :results output :session :tangle no
p = lambda x: x
q = lambda x: 1
r = lambda x: 2 / x ** 3
x,y = finite_difference_method(p, q, r, 1, 0.2, (1,5), 100)
print("x:", list(x))
print("y:", list(y))
#+end_src

#+RESULTS:
: x: [1.0, 1.04, 1.08, 1.12, 1.16, 1.2, 1.24, 1.28, 1.32, 1.3599999999999999, 1.4, 1.44, 1.48, 1.52, 1.56, 1.6, 1.6400000000000001, 1.6800000000000002, 1.72, 1.76, 1.8, 1.8399999999999999, 1.88, 1.92, 1.96, 2.0, 2.04, 2.08, 2.12, 2.16, 2.2, 2.24, 2.2800000000000002, 2.3200000000000003, 2.3600000000000003, 2.4000000000000004, 2.44, 2.48, 2.52, 2.56, 2.6, 2.64, 2.6799999999999997, 2.7199999999999998, 2.76, 2.8, 2.84, 2.88, 2.92, 2.96, 3.0, 3.04, 3.08, 3.12, 3.16, 3.2, 3.24, 3.2800000000000002, 3.32, 3.36, 3.4, 3.44, 3.48, 3.52, 3.56, 3.6, 3.64, 3.68, 3.72, 3.7600000000000002, 3.8000000000000003, 3.84, 3.88, 3.92, 3.96, 4.0, 4.04, 4.08, 4.12, 4.16, 4.2, 4.24, 4.28, 4.32, 4.359999999999999, 4.4, 4.4399999999999995, 4.48, 4.52, 4.5600000000000005, 4.6, 4.640000000000001, 4.68, 4.720000000000001, 4.76, 4.800000000000001, 4.84, 4.88, 4.92, 4.96, 5.0]
: y: [1, 4.4913889643059557e+33, 8.806783063239421e+33, 4.304834407011117e+33, 2.1025210413139832e+33, 1.0260504362287665e+33, 5.0031236298924665e+32, 2.4375730235167532e+32, 1.1866362680429279e+32, 5.771927810584505e+31, 2.805221509860415e+31, 1.3622478555077555e+31, 6.609787756140748e+30, 3.204505414947533e+30, 1.5523023832599564e+30, 7.513342070854547e+29, 3.633550721716228e+29, 1.7557805046182735e+29, 8.47714967857264e+28, 4.089496267800631e+28, 1.971196042752822e+28, 9.493570070012593e+27, 4.568448586848587e+27, 2.1965801958348723e+27, 1.0552715409246669e+27, 5.065472104918165e+26, 2.429483023941566e+26, 1.1642486593548914e+26, 5.574619879724861e+25, 2.6669944028899515e+25, 1.2748702261616235e+25, 6.089008474273143e+24, 2.905785818657927e+24, 1.3855325666102747e+24, 6.600938526776368e+23, 3.1421733754558974e+23, 1.4944789435621573e+23, 7.102060207415689e+22, 3.3722012495642842e+22, 1.599841280268907e+22, 7.583580169460126e+21, 3.591743605439748e+21, 1.6996900195206483e+21, 8.036503969196351e+20, 3.796621779212665e+20, 1.7920904561351547e+20, 8.451905428615039e+19, 3.9827324142034895e+19, 1.8751633828663914e+19, 8.821212236745576e+18, 4.146181291132214e+18, 1.9471474888410678e+18, 9.136495411268641e+17, 4.283416913436498e+17, 2.006460680474651e+17, 9.390749227960898e+16, 4.391357552643586e+16, 2.0517573857075748e+16, 9578147987635682.0, 4467505476247339.5, 2081978970945003.2, 969426659133065.1, 451004249093080.7, 209639465106016.34, 97362533354592.72, 45179017276052.02, 20946306970511.727, 9702945555085.17, 4490811731730.067, 2076686320388.3647, 959492160818.9247, 442931033471.56586, 204293530226.29373, 94144860252.16492, 43347273785.16943, 19941131945.135876, 9165588224.183134, 4209137038.203982, 1931290695.3869352, 885367876.7421094, 405528212.1288577, 185583454.39148206, 84855104.64580457, 38764742.05040113, 17693579.305159263, 8068894.479271968, 3676474.702767021, 1673662.9442070096, 761242.3782826102, 345936.28459792654, 157067.7934696478, 71251.77679734433, 32293.970762648834, 14623.92839131014, 6616.421623071004, 2990.8764263008866, 1350.795493825348, 609.5316056151869, 274.8008060410673, 123.7811649967178, 0.2]

* Test

** concat list
#+begin_src python :results output :session :tangle no
print([1,2] + [3,4])
#+end_src

#+RESULTS:
: [1, 2, 3, 4]

** List multiple
#+begin_src python :results output :session :tangle no
print(5*[0])
#+end_src

#+RESULTS:
: [0, 0, 0, 0, 0]

** Numpy linspace
#+begin_src python :results output :session :tangle no
print(list(np.linspace(1,10,5)))
#+end_src

#+RESULTS:
: [1.0, 3.25, 5.5, 7.75, 10.0]

