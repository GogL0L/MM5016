#+title: Lab 11: Boundary Value Problems
#+description: 
#+PROPERTY: header-args :tangle ./lab11.py :padline 2



* Header
#+begin_src python :results output :session :padline 0
import matplotlib.pyplot as plt
import numpy as np


## Description
"""
The methods are written to output the desired function. In order to
see the solutions to all the tasks run this as a python 3 file
in a terminal.
"""
#+end_src

#+RESULTS:

* Linear algebra från tidigare labbar

** matrix multiply
#+begin_src python :results output :session
def matrix_multiply(matrix1, matrix2):
    m = len(matrix1)
    n = len(matrix2)
    p = len(matrix2[0])
    element = lambda i,j: sum([matrix1[i][k] * matrix2[k][j]
                               for k in range(n)])
    row = lambda i: [element(i,j) for j in range(p)]
    return [row(i) for i in range(m)]
#+end_src

#+RESULTS:

** Transpose
#+begin_src python :results output :session
def transpose(matrix):
    """ Transposes an n by m matrix. """
    n = len(matrix)
    m = len(matrix[0])
    return [[matrix[i][j] for i in range(n)] for j in range(m)]
#+end_src

#+RESULTS:

*** Test av transpose
#+begin_src python :results output :session :tangle no
matrix = [[1,2,3],[4,5,6],[7,8,9]]
vector = [[1],[2],[3]]
print("Matrix tranposed:", transpose(matrix))
print("Vector tranposed:", transpose(vector))
#+end_src

#+RESULTS:
: Matrix tranposed: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
: Vector tranposed: [[1, 2, 3]]

** test av allt ovanför
#+begin_src python :results output :session :tangle no
print(matrix_multiply([[1,0],[0,1]], [[3],[4]]))
print(create_identity(3))
print(switch(0,1,3))
print(add_multiple_of_row_to_other_row(3,0,1,3))
print(matrix_multiply(scale_row(3,1,3), [[1,2,3],[4,5,6],[7,8,9]]))
#+end_src

#+RESULTS:
: [[3], [4]]

* Code

** Tridiagonal solver
#+begin_src python :results output :session
def tridiagonal_elimination(A,y):
    """ Returns the solution x to the equation Ax = y,
    where A is an n by n tridiagonal matrix and
    y is an n dimensional column vector. Algorithm copied
    from wikipedia.
    """
    n = len(y)
    a = lambda i: A[i][i-1]
    b = lambda i: A[i][i]
    c = lambda i: A[i][i+1]
    d = lambda i: y[i][0]


    def c_prim(i):
        if i == 0:
            return c(i) / b(i)
        else:
            return c(i) / (b(i) - a(i) * c_prim(i-1))


    def d_prim(i):
        if i == 0:
            return d(i) / b(i)
        else:
            return (d(i) - a(i) * d_prim(i-1)) / (b(i) - a(i) * c_prim(i-1))


    def x(i):
        if i == n-1:
            return d_prim(i)
        else:
            return d_prim(i) - c_prim(i) * x(i+1)


    x_vector = [[x(i)] for i in range(n)]
    return x_vector
#+end_src

#+RESULTS:

*** test
#+begin_src python :results output :session :tangle no
matrix = [[2,3,0,0], [5,7,11,0], [0, 13, 17, 23], [0,0,4,6]]
vector = [[1], [2], [3], [4]]
x = tridiagonal_elimination(matrix, vector)
print("x:", x)
print("vector:", vector)
print("matrix times x:", matrix_multiply(matrix, x))
#+end_src

#+RESULTS:
: x: [[1.9061413673232903], [-0.9374275782155268], [-0.08806488991888758], [0.7253765932792583]]
: vector: [[1], [2], [3], [4]]
: matrix times x: [[1.0], [2.0], [3.0000000000000036], [3.999999999999999]]



** Finite difference method
#+begin_src python :results output :session
def finite_difference_method(p, q, r, ya, yb, interval, partitions):
    """ Numerically solves the function y(x) from the equation 
    y''(x) = p(x) y' + q(x) y + r(x) with boundary values y(a) = ya
    and y(b) = yb, with the specified stepsize, in the interval given
    as a tuple (left, right) symbolising that x ranges from
    left <= x <= right. This function then returns a list of x values
    partitioned according to the interval and stepsize aswell as a corresponding 
    list of y values.
    """
    n = partitions
    left, right = interval
    h = (left - right) / n
    x = np.linspace(left, right, n+1)
    
    first_row_diagonal = [-2 - h ** 2 * q(x[1]), 1 - (h/2) * p(x[1])]
    last_row_diagonal = [1 + (h/2) * p(x[n-1]), -2 - h ** 2 * q(x[n-1])]
    row_i_diagonal = lambda i: [1 + (h/2) * p(x[i]),
                                -2 - h ** 2 * q(x[i]),
                                1 - (h/2) * p(x[i])]
    f_row = [h ** 2 * r(x[1]) - (1 + (h/2) * p(x[1])) * ya if i == 1
             else h ** 2 * r(x[n-1]) - (1 - (h/2) * p(x[n-1])) * yb if i == n-1
             else h ** 2 * r(x[i]) for i in range(1,n)]
    f = transpose(f_row)

    A = [first_row_diagonal + (n-1-2) * [0] if i==1
         else (n-1-2) * [0] + last_row_diagonal if i == n-1
         else (i-1) * [0] + row_i_diagonal(i) + (n-1-i) * [0]
         for i in range(1,n-1)]
    u = tridiagonal_elimination(A,f)
    return x, ([ya] + transpose(u) + [yb])
#+end_src

#+RESULTS:

* Test

** concat list
#+begin_src python :results output :session :tangle no
print([1,2] + [3,4])
#+end_src

#+RESULTS:
: [1, 2, 3, 4]

** List multiple
#+begin_src python :results output :session :tangle no
print(5*[0])
#+end_src

#+RESULTS:
: [0, 0, 0, 0, 0]

** Numpy linspace
#+begin_src python :results output :session :tangle no
print(list(np.linspace(1,10,5)))
#+end_src

#+RESULTS:
: [1.0, 3.25, 5.5, 7.75, 10.0]

