#+title: Lab 4 MM5016
#+description: Solve linear equation AX=B
#+PROPERTY: header-args :tangle ./lab2.py :padline 2

* Header
#+begin_src python :results output :session :padline 0
## Description
"""
The column vector 'X' will be symbolised as a list that is
X = [x1, x2 ,x3, ... , xn]. An m by n matrix 'A' will be symbolised by a list of size
m consisting of lists of size n. I.e. it will be seen as a column vector of size
m consisting of row vectors of size n.
"""
#+end_src

* Row operations

** add multiple of row
#+begin_src python :results output :session
def add_multiple_of_row_to_other_row(matrix, multiple, row, other_row):
    """ Takes the matrix 'matrix' and returns a matrix where 'multiple' 
    times the row 'row' has been added to the row 'other_row'. The rows
    are numbered so the first row is 0.
    """
    scale_row_vector = lambda scalar, vector: [element * scalar
                                               for element in vector]
    add_row_vectors = lambda vector1, vector2: [vector1[i] + vector2[i]
                                                for i in range(len(vector1))]
    row_vector = matrix[row]
    other_row_vector = matrix[other_row]
    row_vector_scaled = scale_row_vector(multiple, row_vector)
    new_other_row_vector = add_row_vectors(other_row_vector, row_vector_scaled)

    new_matrix = [new_other_row_vector if i == other_row
                  else matrix[i] for i in range(len(matrix))]
    return new_matrix
#+end_src

#+RESULTS:

** transpose
#+begin_src python :results output :session
def transpose(matrix):
    """ Returns the n by m transpose of the m by n matrix 'matrix'. """
    m,n = len(matrix), len(matrix[0])
    return [[matrix[i][j] for i in range(m)] for j in range(n)]
#+end_src

#+RESULTS:

** detach first column
#+begin_src python :results output :session
def detach_first_column(matrix):
    """ Takes the matrix 'matrix' and returns a matrix with only the
    first column, and a matrix with the rest of the matrix 'matrix'.
    """
    first_column_as_row_vector = transpose(matrix)[0]
    rest_of_matrix_as_row_vectors = transpose(matrix)[1:]
    first_column_matrix = [[x] for x in first_column_as_row_vector]
    rest_of_matrix = transpose(rest_of_matrix_as_row_vectors)
    return first_column_matrix, rest_of_matrix
#+end_src

#+RESULTS:

** swap rows
#+begin_src python :results output :session
def swap_row_with_other_row(matrix, row, other_row):
    """ Takes the matrix 'matrix' and returns the matrix where the rows 'row'
    and 'other_row' has been swapped. Rows are numbered so the first row is 0.
    """
    return [matrix[row] if i == other_row
            else matrix[other_row] if i == row
            else matrix[i] for i in range(len(matrix))]
#+end_src

#+RESULTS:

** swap columns
#+begin_src python :results output :session
def swap_column_with_other_column(matrix, column, other_column):
    """ Takes the matrix 'matrix' and returns the matrix where the columns
    'column' and 'other_column' has been swapped. Columns are numbered so the 
    first column is 0.
    """
    return transpose(swap_row_with_other_row(transpose(matrix),
                                             column,
                                             other_column))
#+end_src

#+RESULTS:

** eliminate column
#+begin_src python :results output :session
def eliminate_column(matrix, column):
    """ Takes the matrix 'matrix' and returns a matrix where the column
    'column' has been eliminated except for on the first row, and the boolean
    'sucess' which is by default True. In the case 
    where the whole column is zero, the original matrix is returned, and
    sucess is False. Columns are numbered so the first one i zero.
    """
    column = [matrix[i][column] for i in range(len(matrix))]
    try:
        column_index_range = range(len(column))
        non_zero_positions = filter(lambda row: column[row]!=0,
                                    column_index_range)
        first_non_zero_row = list(non_zero_positions)[0]
    except ValueError:
        return matrix, False

    # Getting the non_zero element of the column to the top.
    matrix = swap_row_with_other_row(matrix, 0, first_non_zero_row)

    # Range starts from one because we don't want to change the first row.
    for row in range(1,len(matrix)):
        coefficient = - matrix[row][0] / matrix[0][0]
        matrix = add_multiple_of_row_to_other_row(matrix, coefficient, 0, row)
    return matrix, True
    
#+end_src

#+RESULTS:

** Gaussian elimination
#+begin_src python :results output :session
def gaussian_elimination(matrix):
    """ Takes the matrix 'matrix' and returns the matrix where gaussian
    elimination has been performed on it, so it is on upper triangular
    form. 
    """
    scale_row = lambda matrix, scalar, row: (
        add_multiple_of_row_to_other_row(matrix, scalar, row, row))
    # Normalises the first row, with respect to the first 
    normalise = lambda matrix: scale_row(matrix, matrix[0][0], 0)

    if len(matrix) == 1:
        return normalise(matrix)
    else:
        matrix = normalise(matrix)
        matrix,sucess = eliminate_column(matrix, 0)
        if sucess == True:
            return matrix[0] + gaussian_elimination(matrix[1:])
        
                                                                     
#+end_src

* Testing

** stuff
#+begin_src python :results output :session :tangle no
matrix = [[1,2,3],[4,5,6],[7,8,9]]
new_matrix = add_multiple_of_row_to_other_row(matrix, -1, 0, 1)
swapped_matrix = swap_row_with_other_row(matrix,0,0)
print(new_matrix)
print(swapped_matrix)
#+end_src

#+RESULTS:
: [[1, 2, 3], [3, 3, 3], [7, 8, 9]]
: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

** detach
#+begin_src python :results output :session :tangle no
print(detach_first_column(matrix))
#+end_src

#+RESULTS:
: ([[1], [4], [7]], [[2, 3], [5, 6], [8, 9]])

** list slicing
#+begin_src python :results output :session :tangle no
matrix = [[1,2,3],[4,5,6],[7,8,9]]
print(matrix[0:2][0:1])
print(matrix[1:])
#+end_src

#+RESULTS:
: [[1, 2, 3]]
: [[4, 5, 6], [7, 8, 9]]

** get index
#+begin_src python :results output :session :tangle no
mylist = [1,2,3,0,0,4,0]
print(mylist.index(5))
#+end_src

#+RESULTS:

** Pureness python list functions
#+begin_src python :results output :session :tangle no
def pure(mylist):
    mylist = [420]
    return mylist

static_list = [3,4,5]
print(static_list)
pure(static_list)
print(static_list)
#+end_src

#+RESULTS:
: [3, 4, 5]
: [3, 4, 5]

** List comprehension
#+begin_src python :results output :tangle no
print ([(letter, number) for letter in ['a', 'b', 'c'] for number in range(2)])
#+end_src

#+RESULTS:
: [('a', 0), ('a', 1), ('b', 0), ('b', 1), ('c', 0), ('c', 1)]

** eliminate_first column and transpose
#+begin_src python :results output :session :tangle no
matrix = [[1,2,3],[4,5,6],[7,8,9]]
print(eliminate_first_column(matrix))
print(transpose(matrix))
#+end_src

#+RESULTS:
: [[1, 2, 3], [0.0, -3.0, -6.0], [0.0, -6.0, -12.0]]
: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
