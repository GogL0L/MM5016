#+title: Lab 4 MM5016
#+description: Solve linear equation AX=B
#+PROPERTY: header-args :tangle ./lab2.py :padline 2

* Header
#+begin_src python :results output :session :padline 0
## Description
"""
The column vector 'X' will be symbolised as a list that is
X = [x1, x2 ,x3, ... , xn]. An m by n matrix 'A' will be symbolised by a list of size
m consisting of lists of size n. I.e. it will be seen as a column vector of size
m consisting of row vectors of size n.
"""
#+end_src

* Row operations

** add multiple of row
#+begin_src python :results output :session
def add_multiple_of_row_to_other_row(matrix, multiple, row, other_row):
    """ Takes the matrix 'matrix' and returns a matrix where 'multiple' 
    times the row 'row' has been added to the row 'other_row'. The rows
    are numbered so the first row is 0.
    """
    scale_row_vector = lambda scalar, vector: [element * scalar
                                               for element in vector]
    add_row_vectors = lambda vector1, vector2: [vector1[i] + vector2[i]
                                                for i in range(len(vector1))]
    row_vector = matrix[row]
    other_row_vector = matrix[other_row]
    row_vector_scaled = scale_row_vector(multiple, row_vector)
    new_other_row_vector = add_row_vectors(other_row_vector, row_vector_scaled)

    new_matrix = [new_other_row_vector if i == other_row
                  else matrix[i] for i in range(len(matrix))]
    return new_matrix
#+end_src

#+RESULTS:

** swap rows
#+begin_src python :results output :session
def swap_row_with_other_row(matrix, row, other_row):
    """ Takes the matrix 'matrix' and returns the matrix where the rows 'row'
    and 'other_row' has been swapped. Rows are numbered so the first row is 0.
    """
    return [matrix[row] if i == other_row
            else matrix[other_row] if i == row
            else matrix[i] for i in range(len(matrix))]
#+end_src

#+RESULTS:

** eliminate column
#+begin_src python :results output :session
def eliminate_first_column(matrix):
    """ Takes the matrix 'matrix' and returns a matrix where the first 
    column has been eliminated except for on the first row. In the case 
    where the whole column is zero, the original matrix is returned.
    """
    first_column = [matrix[i][0] for i in range(len(matrix))]
    try:
        column_index_range = range(len(first_column))
        non_zero_positions = filter(lambda row: first_column[row]!=0,
                                    column_index_range)
        first_non_zero_row = list(non_zero_positions)[0]
    except ValueError:
        return matrix

    # Getting the non_zero element of the column to the top.
    matrix = swap_row_with_other_row(matrix, 0, first_non_zero_row)

    # Range starts from one because we don't want to change the first row.
    for row in range(1,len(matrix)):
        coefficient = - matrix[row][0] / matrix[0][0]
        matrix = add_multiple_of_row_to_other_row(matrix, coefficient, 0, row)
    return matrix
    
#+end_src

#+RESULTS:

* Testing

** stuff
#+begin_src python :results output :session :tangle no
matrix = [[1,2,3],[4,5,6],[7,8,9]]
new_matrix = add_multiple_of_row_to_other_row(matrix, -1, 0, 1)
swapped_matrix = swap_row_with_other_row(matrix,0,0)
print(new_matrix)
print(swapped_matrix)
#+end_src

#+RESULTS:
: [[1, 2, 3], [3, 3, 3], [7, 8, 9]]
: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

** list slicing
#+begin_src python :results output :session :tangle no
matrix = [[1,2,3],[4,5,6],[7,8,9]]
print(matrix[0:2][0:1])
#+end_src

#+RESULTS:
: [[1, 2, 3]]

** get index
#+begin_src python :results output :session :tangle no
mylist = [1,2,3,0,0,4,0]
print(mylist.index(5))
#+end_src

#+RESULTS:

** Pureness python list functions
#+begin_src python :results output :session :tangle no
def pure(mylist):
    mylist = [420]
    return mylist

static_list = [3,4,5]
print(static_list)
pure(static_list)
print(static_list)
#+end_src

#+RESULTS:
: [3, 4, 5]
: [3, 4, 5]

** eliminate_first column
#+begin_src python :results output :session :tangle no
matrix = [[1,2,3],[4,5,6],[7,8,9]]
print(eliminate_first_column(matrix))
#+end_src

#+RESULTS:
: [[1, 2, 3], [0.0, -3.0, -6.0], [0.0, -6.0, -12.0]]
