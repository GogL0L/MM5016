#+title: Lab 7
#+description: 
#+PROPERTY: header-args :tangle ./lab7.py :padline 2

* Header
#+begin_src python :results output :session :padline 0
## Description
"""
The column vector 'X' will be symbolised as a list of size 1 lists, that is
X = [[x1], [x2] ,[x3], ... , [xn]]. An m by n matrix 'A' will be symbolised by a list of size
m consisting of lists of size n. The solution to task 2 in the lab will be the function
'jacobi_method'.
"""

from math import sqrt
#+end_src

#+RESULTS:

* Linear algebra

** Linear algebra operation

*** matrix multiply
#+begin_src python :results output :session
def matrix_multiply(matrix1, matrix2):
    m = len(matrix1)
    n = len(matrix2)
    p = len(matrix2[0])
    element = lambda i,j: sum([matrix1[i][k] * matrix2[k][j]
                               for k in range(n)])
    row = lambda i: [element(i,j) for j in range(p)]
    return [row(i) for i in range(m)]
#+end_src

#+RESULTS:

*** Transpose
#+begin_src python :results output :session
def transpose(matrix):
    """ Transposes an n by m matrix. """
    n = len(matrix)
    m = len(matrix[0])
    return [[matrix[i][j] for i in range(n)] for j in range(m)]
#+end_src

#+RESULTS:

**** Test av transpose
#+begin_src python :results output :session :tangle no
matrix = [[1,2,3],[4,5,6],[7,8,9]]
vector = [[1],[2],[3]]
print("Matrix tranposed:", transpose(matrix))
print("Vector tranposed:", transpose(vector))
#+end_src

#+RESULTS:
: Matrix tranposed: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
: Vector tranposed: [[1, 2, 3]]

*** Dot product
#+begin_src python :results output :session
def dot_product(v,u):
    """ Takes the dot product of the vectors v and u. I.e. the inner product
    given that the coordinates are in a orthonormal basis.
    """
    n = len(v)
    vt = transpose(v)
    return matrix_multiply(vt,u)[0][0]
#+end_src

#+RESULTS:

**** Test av dot product
#+begin_src python :results output :session :tangle no
v = [[1], [2], [3]]
u = [[2], [1], [3]]
print(dot_product(v,u))
#+end_src

#+RESULTS:
: 13

*** matrix add
#+begin_src python :results output :session
def matrix_add(A,B):
    """ Add matrices componentwise. """
    n = len(A)
    m = len(A[0])
    return [[A[i][j] + B[i][j] for j in range(m)] for i in range(n)]
#+end_src

#+RESULTS:

**** test av matrix add
#+begin_src python :results output :session :tangle no
A = [[1,2], [3,4]]
B = [[2,4], [5,6]]
print(matrix_add(A,B))
#+end_src

#+RESULTS:
: [[3, 6], [8, 10]]

*** Scale
#+begin_src python :results output :session
def scale(l,A):
    """ Scales the matrix 'A' with the scalar m. """
    n = len(A)
    m = len(A[0])
    return [[l * A[i][j] for j in range(m)] for i in range(n)]
#+end_src

#+RESULTS:

**** Test av scalar product
#+begin_src python :results output :session :tangle no
A = [[1,2], [3,4]]
v = [[2], [3]]
print ("2 times A:", scale(-2, A))
print ("3 times v:", scale(3, v))
#+end_src

#+RESULTS:
: 2 times A: [[-2, -4], [-6, -8]]
: 3 times v: [[6], [9]]

*** matrix sub
#+begin_src python :results output :session
def matrix_sub(A,B):
    """ Add vectors componentwise. """
    negative_B = scale(-1, B)
    return matrix_add(A, negative_B)
#+end_src

#+RESULTS:

**** Test
#+begin_src python :results output :session :tangle no
A = [[1,2], [3,4]]
B = [[0,2], [4,1]]
print(matrix_sub(A,B))
#+end_src

#+RESULTS:
: [[1, 0], [-1, 3]]

*** Euclidean norm
#+begin_src python :results output :session
def norm(A):
    """ Returns the euclidean norm given the basis is orthonormal. """
    return sqrt(dot_product(A,A))
#+end_src

#+RESULTS:

**** test av euclidean norm
#+begin_src python :results output :session :tangle no
A = [[3], [0], [4]]
print(norm(A))
#+end_src

#+RESULTS:
: 5.0

*** Normalise
#+begin_src python :results output :session
def normalise(v):
    """ Normalises the vector 'v' using the euclidean norm. """
    return scale(1 / norm(v), v)
#+end_src

#+RESULTS:

**** Test of normalise
#+begin_src python :results output :session
v = [[ 0 ],[ 1 ],[ 1 ]]
print(normalise(v))
#+end_src

#+RESULTS:
: [[0.0], [0.7071067811865475], [0.7071067811865475]]

*** Projection
#+begin_src python :results output :session
def projection(u,v):
    """ Takes the projection of v on u, given that the coordinates
    are in a orthnormal basis.
    """
    scalar = dot_product(u,v) / dot_product(u,u)
    return scale(scalar, u)
    
#+end_src

#+RESULTS:

*** Test of above
#+begin_src python :results output :session :tangle no
u,v = [[ 3 ],[ 3 ]], [[ 5 ],[ 0 ]]
print(projection(v,u))
#+end_src

#+RESULTS:
: [[3.0], [0.0]]

** Related to jacobi method

*** simple decompose matrix
#+begin_src python :results output :session
def additive_decomposition(A):
    """ Decomposes an n by n matrix 'A' into an lower triangular
    matrix 'L', diagonal matrix 'U' and an upper triangular
    matrix 'U' such that 'A = D + L + U'. This function
    returns the 3 tuple '(D, L, U)'.
    """
    n = len(A)
    D = [[A[i][j] if i==j else 0 for j in range(n)] for i in range(n)]
    L = [[A[i][j] if i<j else 0 for j in range(n)] for i in range(n)]
    U = [[A[i][j] if i>j else 0 for j in range(n)] for i in range(n)]
    return D,L,U
#+end_src

#+RESULTS:

**** Test additive decomposition
#+begin_src python :results output :session :tangle no
A = [[1,2,3], [4,5,6], [7,8,9]]
D,L,U = additive_decomposition(A)
print("D:",D)
print("L:",L)
print("U:",U)
#+end_src

#+RESULTS:
: D: [[1, 0, 0], [0, 5, 0], [0, 0, 9]]
: L: [[0, 2, 3], [0, 0, 6], [0, 0, 0]]
: U: [[0, 0, 0], [4, 0, 0], [7, 8, 0]]

*** Diagonal inverse
#+begin_src python :results output :session
def diagonal_inverse(D):
    """ Given a diagonal n by n matrix 'D' with non-zero diagonals this function 
    returns the inverse matrix.
    """
    n = len(D)
    return [[1 / D[i][j] if i==j else 0 for j in range(n)] for i in range(n)]
#+end_src

#+RESULTS:

**** diagonal inverse test
#+begin_src python :results output :session :tangle no
D = [[1,0,0], [0, 4, 0], [0,0,10]]
print(diagonal_inverse(D))
#+end_src

#+RESULTS:
: [[1.0, 0, 0], [0, 0.25, 0], [0, 0, 0.1]]

*** Euclidean distance
#+begin_src python :results output :session
def euclidean_distance(v,u):
    """ Given the n by 1 vectors 'v' and 'u', this function will return
    the euclidean distance between them.
    """
    uv = matrix_sub(v,u)
    return norm(uv)
#+end_src

#+RESULTS:

**** test
#+begin_src python :results output :session :tangle no
u, v = [[0], [3], [0]], [[0], [0], [4]]
print(euclidean_distance(v,u))
#+end_src

#+RESULTS:
: 5.0

*** get zero matrix
#+begin_src python :results output :session
def zero_matrix(A):
    """ Returns the zero matrix of the same size. """
    n = len(A)
    m = len(A[0])
    return [[0 for j in range(m)] for i in range(n)]
#+end_src

#+RESULTS:

**** test
#+begin_src python :results output :session :tangle no
A = [[1,2], [3,4]]
v = [[1], [5]]
print("2x2 zero matrix:", zero_matrix(A))
print("2x1 zero matrix:", zero_matrix(v))
#+end_src

#+RESULTS:
: 2x2 zero matrix: [[0, 0], [0, 0]]
: 2x1 zero matrix: [[0], [0]]

* Jacobi method
#+begin_src python :results output :session
def jacobi_method(A, b,
                  approximate_solution = zero_matrix(b) ,
                  tolerance=0.001, iteration=0, max_iterations=100):
    """ Given an n by n matrix A and an n by 1 vector b, this function 
    returns the solution x to the equation Ax = b, with the accuracy
    specified by the tolerance. If the tolerance is not met within
    'max_iterations' ammount of iterations, an exception will be raised.
    """
    if iteration > max_iterations:
        raise RecursionError("<jacobi_method: max iterations exceded!">)

    b_approximate = matrix_multiply(A, approximate_solution)
    distance = euclidean_distance(b, b_approximate)
    if distance <= tolerance:
        return approximate_solution
    else:
        x = approximate_solution
        D, L, U = additive_decomposition(A)
        D_inverse = diagonal_inverse(D)
        x_new = D
        

    
#+end_src

#+RESULTS:

* Gradient Descent method

* Test

** Transpose av vector
#+begin_src python :results output :session :tangle no
vector = [[1], [2], [3]]
print(transpose(vector))
#+end_src

#+RESULTS:

